'use strict';
sap.ui.define([
    'open/ux/preview/client/thirdparty/@sap-ux-private/control-property-editor-common',
    './flex-change',
    'sap/base/Log'
], function (___sap_ux_private_control_property_editor_common, ___flex_change, Log) {
    'use strict';
    const changeProperty = ___sap_ux_private_control_property_editor_common['changeProperty'];
    const changeStackModified = ___sap_ux_private_control_property_editor_common['changeStackModified'];
    const deletePropertyChanges = ___sap_ux_private_control_property_editor_common['deletePropertyChanges'];
    const propertyChangeFailed = ___sap_ux_private_control_property_editor_common['propertyChangeFailed'];
    const FlexChangesEndPoints = ___sap_ux_private_control_property_editor_common['FlexChangesEndPoints'];
    const applyChange = ___flex_change['applyChange'];
    function assertProperties(properties, target) {
        for (const property of properties) {
            const value = target[property];
            if (value === null || value === undefined) {
                throw new Error(`Invalid change, missing ${ property } in the change file`);
            }
        }
    }
    function assertChange(change) {
        assertProperties([
            'fileName',
            'selector',
            'content',
            'creation'
        ], change);
        assertProperties(['id'], change.selector);
        assertProperties(['property'], change.content);
    }
    function modifyRTAErrorMessage(errorMessage, id, type) {
        return errorMessage.replace('Error: Applying property changes failed:', '').replace(`${ type }#${ id }`, '');
    }
    class ChangeService {
        savedChanges = [];
        constructor(options, selectionService) {
            this.options = options;
            this.selectionService = selectionService;
        }
        async init(sendAction, subscribe) {
            subscribe(async action => {
                if (changeProperty.match(action)) {
                    try {
                        this.selectionService.applyControlPropertyChange(action.payload.controlId, action.payload.propertyName);
                        await applyChange(this.options, action.payload);
                    } catch (exception) {
                        let name = '';
                        const id = action.payload.controlId || '';
                        const control = sap.ui.getCore().byId(id);
                        if (control) {
                            name = control.getMetadata().getName();
                        }
                        const modifiedMessage = modifyRTAErrorMessage(exception?.toString(), id, name);
                        const errorMessage = modifiedMessage || `RTA Exception applying expression "${ action.payload.value }"`;
                        const propertyChangeFailedAction = propertyChangeFailed({
                            ...action.payload,
                            errorMessage
                        });
                        sendAction(propertyChangeFailedAction);
                    }
                } else if (deletePropertyChanges.match(action)) {
                    await this.deleteChange(action.payload.controlId, action.payload.propertyName, action.payload.fileName);
                }
            });
            const savedChangesResponse = await fetch(FlexChangesEndPoints.changes + `?_=${ Date.now() }`);
            const savedChanges = await savedChangesResponse.json();
            const changes = Object.keys(savedChanges ?? {}).map(key => {
                const change = savedChanges[key];
                try {
                    assertChange(change);
                    if ([
                            change.content.newValue,
                            change.content.newBinding
                        ].every(item => item === undefined || item === null)) {
                        throw new Error('Invalid change, missing new value in the change file');
                    }
                    return {
                        type: 'saved',
                        kind: 'valid',
                        fileName: change.fileName,
                        controlId: change.selector.id,
                        propertyName: change.content.property,
                        value: change.content.newValue ?? change.content.newBinding,
                        timestamp: new Date(change.creation).getTime(),
                        controlName: change.selector.type.split('.').pop()
                    };
                } catch (error) {
                    if (change.fileName) {
                        const unknownChange = {
                            type: 'saved',
                            kind: 'unknown',
                            fileName: change.fileName
                        };
                        if (change.creation) {
                            unknownChange.timestamp = new Date(change.creation).getTime();
                        }
                        return unknownChange;
                    }
                    return undefined;
                }
            }).filter(change => !!change).sort((a, b) => b.timestamp - a.timestamp);
            this.savedChanges = changes;
            sendAction(changeStackModified({
                saved: changes,
                pending: []
            }));
            this.options.rta.attachUndoRedoStackModified(this.createOnStackChangeHandler(sendAction));
        }
        async deleteChange(controlId, propertyName, fileName) {
            const filesToDelete = this.savedChanges.filter(change => fileName ? fileName === change.fileName : change.controlId === controlId && change.propertyName === propertyName).map(change => fetch(FlexChangesEndPoints.changes, {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ fileName: change.fileName })
            }));
            await Promise.all(filesToDelete).catch(error => Log.error(error));
        }
        createOnStackChangeHandler(sendAction) {
            return () => {
                const stack = this.options.rta.getCommandStack();
                const allCommands = stack.getCommands();
                const executedCommands = stack.getAllExecutedCommands();
                const inactiveCommandCount = allCommands.length - executedCommands.length;
                const activeChanges = allCommands.map((command, i) => {
                    let result;
                    try {
                        const selector = command.getProperty('selector');
                        const changeType = command.getProperty('changeType');
                        let value = '';
                        switch (changeType) {
                        case 'propertyChange':
                            value = command.getProperty('newValue');
                            break;
                        case 'propertyBindingChange':
                            value = command.getProperty('newBinding');
                            break;
                        default:
                            throw new Error(`Invalid changeType ${ changeType }`);
                        }
                        result = {
                            type: 'pending',
                            controlId: selector.id,
                            propertyName: command.getProperty('propertyName'),
                            isActive: i >= inactiveCommandCount,
                            value,
                            controlName: command.getElement().getMetadata().getName().split('.').pop() ?? ''
                        };
                    } catch (error) {
                        Log.error('Failed: ', error);
                    }
                    return result;
                }).filter(change => !!change);
                sendAction(changeStackModified({
                    saved: this.savedChanges,
                    pending: activeChanges
                }));
            };
        }
    }
    var __exports = { __esModule: true };
    __exports.ChangeService = ChangeService;
    return __exports;
});